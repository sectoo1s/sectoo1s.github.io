[{"title":"Shiro反序列化漏洞","url":"/2022/10/05/Shiro反序列化漏洞/","content":"\n\n\n\n\n\n\n\n\n一文看懂shiro反序列化：https://cloud.tencent.com/developer/article/2069873\n\nShiro反序列化漏洞利用汇总：https://cloud.tencent.com/developer/article/1657019\n\n**shiro 721** 反序列化漏洞复现与原理以及**Padding Oracle Attack**攻击加解密原理：\n\nhttps://blog.csdn.net/qq_41874930/article/details/121314926\n\n","tags":["shiro"]},{"title":"JAVA原生序列化与反序列化","url":"/2022/10/05/JAVA原生序列化与反序列化/","content":"\n创建一个student类\n\n```java\nimport java.io.Serializable;\n\npublic class Student implements Serializable {\n    //private static final long serialVersionUID = 1L;\n    private Integer stuId;\n    private String stuName;\n    private Integer stuAge;\n\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"stuId=\" + stuId +\n                \", stuName='\" + stuName + '\\'' +\n                \", stuAge=\" + stuAge +\n                '}';\n    }\n\n    public Student(Integer stuId, String stuName, Integer stuAge) {\n        this.stuId = stuId;\n        this.stuName = stuName;\n        this.stuAge = stuAge;\n    }\n\n    public Integer getStuId() {\n        return stuId;\n    }\n\n    public void setStuId(Integer stuId) {\n        this.stuId = stuId;\n    }\n\n    public String getStuName() {\n        return stuName;\n    }\n\n    public void setStuName(String stuName) {\n        this.stuName = stuName;\n    }\n\n    public Integer getStuAge() {\n        return stuAge;\n    }\n\n    public void setStuAge(Integer stuAge) {\n        this.stuAge = stuAge;\n    }\n}\n```\n\n序列化\n\n```java\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\n\npublic class Demo1 {\n    public static void main(String[] args) throws IOException {\n        Student stu = new Student(100,\"张三\",18);\n        OutputStream os = new FileOutputStream(\"/Users/hx/zs.txt\");\n        ObjectOutputStream oos = new ObjectOutputStream(os);\n        oos.writeObject(stu);\n        oos.flush();\n        System.out.println(\"对象序列化成功\");\n        oos.close();\n        os.close();\n    }\n}\n```\n\n反序列化\n\n```java\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\n\npublic class Demo2 {\n    public static void main(String[] args) throws IOException, ClassNotFoundException {\n        InputStream is = new FileInputStream(\"/Users/hx/zs.txt\");\n        ObjectInputStream ois = new ObjectInputStream(is);\n        Object obj = ois.readObject();\n        Student stu = (Student)obj;\n        System.out.println(stu.toString());\n        ois.close();\n        is.close();\n    }\n}\n```\n\n\n\n\n\n序列化视频教程：https://www.bilibili.com/video/BV13q4y1e75T/?spm_id_from=333.788\n\njava序列化与反序列化全讲解:https://blog.csdn.net/mocas_wang/article/details/107621010\n","tags":["java"]},{"title":"Headers格式化小脚本","url":"/2022/10/03/Headers格式化小脚本/","content":"\n​\tJS逆向的时候用它来处理headers请求头。\n\n```python\n# 作者：hx\n# 开发时间：2022/8/28 2:37 下午\nimport re\n\nheaderStr = '''\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7\nCache-Control: no-cache\nConnection: keep-alive\nCookie: PHPSESSID=e20lbeo6aig5mbd4plnjvrf3v1; __btu__=96167b4df9c899d8ef48da9f26e664ecca6aae25; __btc__=fe4cda68c139654ccd067c400d321b014c44ed50; notice=0; _currentUrl_=%2FMessage; __btuc__=\"\"\nHost: www.butian.net\nPragma: no-cache\nReferer: https://www.butian.net/\nsec-ch-ua: \"Chromium\";v=\"104\", \" Not A;Brand\";v=\"99\", \"Google Chrome\";v=\"104\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"macOS\"\nSec-Fetch-Dest: document\nSec-Fetch-Mode: navigate\nSec-Fetch-Site: same-origin\nSec-Fetch-User: ?1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\n'''\nret = \"\"\nfor i in headerStr:\n    if i == '\\n':\n        i = \"',\\n'\"\n    ret += i\n\nret = re.sub(\": \", \"': '\", ret)\nprint(ret[3: -3])\n```\n\n输出结果如下\n\n![image-20221003211922149](https://raw.githubusercontent.com/sectoo1s/images/main/202210032119234.png)\n","tags":["python"]},{"title":"域名泛解析问题","url":"/2022/10/03/域名泛解析问题/","content":"\n#### 1、什么是泛解析？\n\n`泛解析`：是指利用 **“ \\* ”** 来做子域名，实现所有的子域名都指向同一个IP地址（记录值）。\n\n例如域名 example.com，设置泛解析 ***.example.com** 。\n\n则该域名下所有的子域名（如 a.example.com，b.example.com，c.example.com等）\n\n都将指向与 *.dns-example.com 相同的IP地址。\n\n#### 2、会有什么影响？\n\n这就导致我们在子域名信息收集的时候，会得到许多无效资产。\n\n举例说明：淘宝\n\nping 一个绝对不可能存在的域名,他解析了,那么说明他大概率使用了泛解析。\n\n![](https://raw.githubusercontent.com/sectoo1s/images/main/202210032105274.png)\n\n反观百度则是完全不同的结果，这说明它没有使用泛解析。\n\n![image-20221003210639714](https://raw.githubusercontent.com/sectoo1s/images/main/202210032106768.png)\n\n#### 3、检测小脚本\n\n```python\nimport socket\nimport sys\n\ndef dns_resolve(domain):\n    url = 'fadslkhfasnflkasnfas.' + domain\n    flag = False\n    try:\n        socket.getaddrinfo(url, None)\n        flag = True\n    except:\n        pass\n\n    if not flag:\n        print('[+]%s 未采用泛解析!' %domain)\n    else:\n        print('[+]%s 采用了泛解析!' %domain)\n\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        print('请这样输入：python3 %s <domain>'%sys.argv[0])\n        exit(1)\n    dns_resolve(sys.argv[1])\nimport socket\nimport sys\n\ndef dns_resolve(domain):\n    url = 'fadslkhfasnflkasnfas.' + domain\n    flag = False\n    try:\n        socket.getaddrinfo(url, None)\n        flag = True\n    except:\n        pass\n\n    if not flag:\n        print('[+]%s 未采用泛解析!' %domain)\n    else:\n        print('[+]%s 采用了泛解析!' %domain)\n\nif __name__ == '__main__':\n    if len(sys.argv) < 2:\n        print('请这样输入：python3 %s <domain>'%sys.argv[0])\n        exit(1)\n    dns_resolve(sys.argv[1]\n```\n\n\n\n**参考文章**：\n\nsocket模块的getaddrinfo详解：\n\nhttps://blog.csdn.net/qdx411324962/article/details/46924219\n","tags":["DNS"]},{"title":"渗透测试面试题","url":"/2022/10/03/渗透测试面试题/","content":"\n​\t已经很久没有上班了，趁着国庆这段时间背背面试题。\n\n#### 1、渗透测试的流程\n\n![img](https://raw.githubusercontent.com/sectoo1s/images/main/202210031714078.png)\n\n\n\n#### 2、信息收集如何处理子域名爆破的泛解析问题\n\n`泛解析`:意味着我们ping一个绝对不存在的域名他都会能够给出ip地址。\n\n如何解决：可以编写一个简单的脚本去对收集到的域名进行解析。\n\n这里使用一个绝对不存在的域名，比如：`asdkasdsdfsa.baidu.com`\n\n如果成功解析出ip，则说明存在泛解析机制。\n\n\n\n#### 3、如何绕过CDN查找真实ip\n\n方法一：多地ping，查看对应ip地址是否唯一\n\nhttp://ping.chinaz.com/\nhttp://ping.aizhan.com/\nhttp://ce.cloud.360.cn/\n\n方法二：nslookup、dig查找解析记录，看ip是否唯一\n\n![image-20221004003728551](https://raw.githubusercontent.com/sectoo1s/images/main/202210040037634.png)\n\n方法三：使用ICO图标查找真实ip地址\n\n\n\n#### 4、phpinfo你会关注那些信息？\n\n1. **网站真实ip**\n\n   ![image-20221004005459821](https://raw.githubusercontent.com/sectoo1s/images/main/202210040057962.png)\n\n2. **网站绝对路径**\n\n   当网站绝对路径泄漏时，如果能写webshell，则可以直接getshell；\n\n   当日志文件路径泄露时，如果存在文件包含，则直接包含日志文件getshell。\n\n   ![](https://raw.githubusercontent.com/sectoo1s/images/main/202210040057837.png)\n\n3. **应用信息**\n\n   通过phpinfo可以查看到支持的特殊服务。\n\n   例如:redis、fastcgi、memcache、ImageMagick等。\n\n   如果存在redis、memcache等则可尝试未授权访问获取信息。\n\n   \n\n4. **一些敏感配置**\n\n   allow_url_include \t #该项如果开启，则支持远程文件包含。\n\n   ​\t\t\t\t\t\t\t\t  #如果有存在文件包含的文件则可直接getshell，或可以使用php伪协议\n   disable_function  \t  #该项表示禁用的函数名\n   magic_quotes_gpc    #php5.4以下版本有的函数，默认开启，会对特殊字符进行转移\n\n   ![image-20221004010350910](https://raw.githubusercontent.com/sectoo1s/images/main/202210040103972.png)\n\n   \n\n5. **版本信息**\n   php版本信息，每个php版本都有变化和特性。\n\n   像php5.3.4以下 + magic_quotes_gpc off 可%00截断\n\n\n\n#### 5、有没有了解过权限维持？\n\n没有\n\n#### 6、说一个你感觉不错的漏洞，展开讲讲\n\n一时想不起来\n\n#### 7、输出到href的XSS如何防御\n\n1. a标签的href属性中一般放的是URL，也就是超链接。\n   所以我们可以规定， 这里的输入必须以http或者https开头，否则不予以输入。\n2. 再对用户的数据进行实体编码或者转译单双引号等操作。\n\n#### 8、samesite防御CSRF的原理\n\nSameSite 有两个属性值，分别是 Strict 和 Lax，下面分别讲解：\n\n- **SameSite:Strict:**\n\n严格模式，表明这个 cookie 在任何情况下都不可能作为第三方 cookie，绝无例外。\n\n- **SameSite:Lax:**\n\n宽松模式，比 Strict 放宽了点限制：假如这个请求是我上面总结的那种同步请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求（因为从语义上说 GET 是读取操作，比 POST 更安全），则这个 cookie 可以作为第三方 cookie。\n\n参考链接：https://www.cnblogs.com/ziyunfei/p/5637945.html\n\n\n\n#### 9、CSRF防御\n\nCSRF 是跨站请求伪造：\n\n攻击者盗用了你的身份，以你的名义发送恶意请求。\n\n对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作。\n\n比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。\n\n\n\n**根本原因**：是从站点B.com向站点A.com发起请求，会把A.com的cookie一同发送过去。\n\n\n\n**防御策略**\n\n1. 验证 HTTP Referer 字段；\n2. 在请求地址中添加 token 并验证；\n3. 在 HTTP 头中自定义属性并验证；\n4. Chrome 浏览器端启用 SameSite cookie\n\n参考链接：https://juejin.cn/post/7031060650801496101\n\n\n\n#### 10、json格式的CSRF如何防御\n\n参考链接：https://cloud.tencent.com/developer/article/1458194\n\n\n\n#### 11、浏览器的编码顺序与解码顺序\n\nhttps://cloud.tencent.com/developer/article/1516371\n\n\n\n#### 12、过滤逗号的SQL注入如何绕过\n\nSQL注入是指网站对用户输入数据没有判断或过滤不严，攻击者可以在其中拼接额外的SQL语句。\n\n在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行恶意操作，从而得到想要的数据信息。\n\n参考链接：https://blog.csdn.net/weixin_43247256/article/details/122711885\n\nsqli靶场：https://cloud.tencent.com/developer/article/2008760\n\nsql注入bypass进阶：https://www.jianshu.com/p/12519879dc44\n\n1. union联合注入，使用join代替逗号。\n2. 使用substring()函数(不需要逗号)和ascii()函数进行盲注。\n\n#### 13、过滤limit后的逗号如何绕过\n\n```bash\n1、limit(0,1)\n2、limit 1 offset 0\n```\n\n\n\n#### 14、Java反序列化和序列化\n\njava序列化就是指将对象转换为字节序列的过程，反序列化则是指将字节序列转换为对象的过程。\n\n原生java下通过ObjectOutputStream类和ObjectInputStream类实现。\n\n序列化的目的：方便数据传输或者存储。常见的序列化格式：二进制格式，json字符串等。\n\n\n\n#### 15、fastjson相关漏洞\n\nfastjson就是一个为了实现对象和字符串相互转换的java库。\n\n**1.2.24版本漏洞**\n\n1. fastjson的反序列化中的autotype功能,允许用户在输入JSON串的时候，\n   通过“@type”键对应的value值指定要进行反序列化的类。\n2. fastjson在进行实例化的时候，会调用该对象的get()、set()方法。\n\n攻击者可以构造恶意请求，使目标应用的代码执行流程进入这部分特定setter或getter方法，从而进行攻击。\n\n\n\n**1.2.47版本漏洞**\n\n在1.2.47版本及以下的情况下，loadClass中默认cache为true。\n\n首先使用java.lang.Class把获取到的类缓存到mapping中，\n\n然后直接从缓存中获取到了com.sun.rowset.jdbcRowSetlmpl这个类，即可绕过黑名单。\n\n浅析FastJSON反序列化漏洞（1.2.24——1.2.68）：https://cloud.tencent.com/developer/article/1957185\n\n最全fastjson漏洞复现与绕过：https://cloud.tencent.com/developer/article/1974944\n\n\n\n#### 16、shiro相关漏洞\n\nshiro是一个java安全框架，执行身份认证、授权、密码和会话管理。\n\n它提供了一个remember me功能，用户登录成功之后会生成经过加密的cookie，cookie的key为RememberMe。\n\ncookie的值是通过反序列化、aes加密、base64编码后形成的。\n\n**shiro550**\n\n- shiro 1.2.24中，提供了硬编码的AES密钥：kPH+bIxk5D2deZiIxcaaaA==\n- 由于开发人员未修改AES密钥而直接使用Shiro框架，导致了该问题。\n\n**shiro721**\n\n由于Apache Shiro cookie中通过 AES-128-CBC 模式加密的rememberMe字段存在问题。\n\n用户可通过Padding Oracle 加密生成的攻击代码来构造恶意的rememberMe字段。\n\n并重新请求网站，进行反序列化攻击，最终导致任意代码执行。\n\n- 采用AES-128-CBC的加密方式，容易受到padding oracle attack(oracle填充攻击)。\n- 攻击者可以通过枚举的方式计算出全部明文并且进行篡改。\n\nShiro反序列化漏洞利用详解（Shiro-550+Shiro-721）:https://zhuanlan.zhihu.com/p/558913284\n\n\n\n#### 17、log4j相关漏洞\n\napache的开源日志记录框架。\n\n该漏洞的主要原因是log4j在日志输出中，未对字符合法性进行严格的限制。\n\n执行了JNDI协议加载的远程恶意脚本，从而造成RCE。\n\nlog4j漏洞分析及总结：https://blog.csdn.net/csd_ct/article/details/122916620\n\n\n\n#### 18、JNDI相关漏洞\n\n\n\n深入理解JNDI注入与Java反序列化漏洞利用：https://kingx.me/Exploit-Java-Deserialization-with-RMI.html\n\nJNDI注入原理：https://cloud.tencent.com/developer/article/1942500\n\n\n\n#### 19、说一个你知道的python相关的漏洞\n\nSSTI服务器端模板注入\n\n是指攻击者能够使用本机模板语法将恶意有效负载注入模板中，然后在服务器端执行该模板。\n\nSSTI入门详解：https://blog.csdn.net/weixin_51353029/article/details/111503731\n\n\n\n#### 20、SSRF的基本原理和怎么防御\n\nSSRF漏洞：https://www.cnblogs.com/happystudyhuan/p/11802961.html\n","tags":["渗透测试"]},{"title":"AutoJS编写的支付宝转账脚本","url":"/2022/10/03/AutoJS编写的支付宝转账脚本/","content":"\n​\t最近刚看完一套JS的基础课程，还发现了autojs这个框架。\n\n我个人有一个关于支付宝的需求，就尝试着写了一下，但是还有很多bug。\n\n先不管行不行的了，先把代码保存在这里，后面有空再修改一下。\n\n```javascript\n//packageName = com.eg.android.AlipayGphone\n/* \n    通过包名打开的速度要快几十倍\n    app.launchApp(\"支付宝\")\n    app.launch(\"com.eg.android.AlipayGphone\")\n*/\n\n//定义一个点击函数\nfunction clickCenter(obj) {\n    let x = obj.bounds().centerX()\n    let y = obj.bounds().centerY()\n    click(x,y)\n}\n\n// 打开支付宝并跳转到转账页面\nfunction getStart() {\n    //启动支付宝app\n    app.launch(\"com.eg.android.AlipayGphone\")\n    sleep(3000)\n\n    //点击转账按钮\n    let obj = text(\"转账\").findOne()\n    clickCenter(obj);\n    sleep(1000)\n\n    //点击转账到支付宝\n    obj = text(\"转到支付宝\").findOne()\n    clickCenter(obj);\n    sleep(1000)\n}\n\n// 读取文件\nfunction readFile(path) {\n    let txt = open(path, mode='r', encoding='utf-8')\n    let arr = txt.readlines()\n    return arr\n}\n\n// 批量检测文本中的手机号信息\nfunction getInfo(arr) {\n    for(let i = 0 ; i < arr.length; i++) {\n    // 选中支付宝转账框并输入手机号\n        obj = id(\"com.alipay.mobile.antui:id/input_edit\").findOne()\n        clickCenter(obj);\n        sleep(random)\n        setText(Trim(arr[i]))\n\n        //点击下一步\n        obj = text(\"下一步\").findOne()\n        clickCenter(obj);\n        sleep(1000)\n        if(id(\"com.alipay.mobile.antui:id/message_content\").exists()){\n            obj = id(\"com.alipay.mobile.antui:id/buttonView\").findOne()\n            clickCenter(obj)\n            sleep(random)\n            let errNumber = id(\"com.alipay.mobile.antui:id/input_edit\").findOne()\n            log(errNumber.text() + \"手机号不存在!\")\n            continue\n        } else if(id(\"android:id/alertTitle\").exists()) {\n            obj = id(\"com.alipay.mobile.socialcontactsdk:id/user_realname\").findOne()\n            clickCenter(obj)\n            sleep(random)\n            let userName = id(\"com.alipay.mobile.transferapp:id/tf_receiveNameTextView\").findOne()\n            let phoneNumber = id(\"com.alipay.mobile.transferapp:id/tf_receiveAccountTextView\").findOne()\n            log(\"姓名:\" + userName.text() + \", 手机号:\" + arr[i])\n            sleep(random)\n\n            //返回到输入手机号页面\n            obj = id(\"com.alipay.mobile.ui:id/title_bar_back_button\").findOne()\n            clickCenter(obj)\n            continue\n        } else {\n            // 获取姓名和手机号信息\n            let userName = id(\"com.alipay.mobile.transferapp:id/tf_receiveNameTextView\").findOne()\n            let phoneNumber = id(\"com.alipay.mobile.transferapp:id/tf_receiveAccountTextView\").findOne()\n            log(\"姓名:\" + userName.text() + \", 手机号:\" + arr[i])\n            sleep(random)\n            //返回到输入手机号页面\n            obj = id(\"com.alipay.mobile.ui:id/title_bar_back_button\").findOne()\n            clickCenter(obj)\n        }\n        \n    }\n}\n\n//去除前后空格\nfunction Trim(str) {\n    return str.replace(/(^\\s*)|(\\s*$)/g, \"\");\n}\n\nconst path = '/sdcard/test/phone.txt'\nlet random = random(5,10) * 100\nlet arr = readFile(path)\ntoastLog(\"检测开始!\")\ngetStart()\ngetInfo(arr)\ntoastLog(\"检测结束!\")\n\n// 如果搜索的手机号不存在，这跳出此次循环\n// if(id(\"com.alipay.mobile.antui:id/message_content\").exists()){\n//     obj = id(\"com.alipay.mobile.antui:id/buttonView\").findOne()\n//     clickCenter(obj)\n//     sleep(1000)\n// } else {\n//     getInfo(arr)\n// }\n\n\n// 目前的问题 大概查询20次左右就会频繁或者发现代理 \n```\n\n","tags":["autojs"]},{"title":"MacOS使用scrcpy连接安卓手机","url":"/2022/09/30/MacOS使用scrcpy连接安卓手机/","content":"\n#### 1、前言\n\n想实现一个批量检测的功能，但是在PC端找不到教程。\n\n在论坛发了很多次帖子都被管理员删除了，感觉非常郁闷。\n\n看b站的时候发现了一个autojs，于是想通过这种方法操作一下。\n\n\n\n####  2、安装scrcpy\n\n由于对手机操作需要进行投屏，于是在这里先安装一个投屏软件。\n\n```javascript\nhttps://github.com/Genymobile/scrcpy\n```\n\n就是这个`scrcpy`,开源且多平台可用，直接开整。\n\n我这里用的是MacOS,直接使用brew安装。\n\n```javascript\nbrew install --cask android-platform-tools\nbrew install scrcpy\n```\n\n上面那条命令使用来安装adb的，如果没有的话先执行这个。\n\n\n\n#### 3、连接手机\n\n1. 连接usb数据线，打开usb调试，数据线连接手机，执行命令。\n   ```javascript\n   adb tcpip 5555\t//开启adb后台进行并监听5555端口\n   ```\n\n2. 拔掉数据线执行命令\n   ```javascript\n   adb connect 手机IP地址:5555\n   ```\n\n3. 终端运行`scrcpy`\n   ```javascript\n   scrcpy\n   ```\n\n   ![image-20220930154112330](https://raw.githubusercontent.com/sectoo1s/images/main/202209301541452.png)\n\n成功连接。\n\n\n\n---\n\n\n\n参考文章：https://blog.csdn.net/msn465780/article/details/127076035\n","tags":["autojs"]},{"title":"Typora基础使用方法","url":"/2022/09/29/Typora基础使用方法/","content":"\n### typora的使用方法\n\n#### 1、标题\n\n“#”符号为标题的等级，“#”符号越少标题越大，最多可以连续写六个“#”符号。输入“#”符号之后一定要加一个空格然后继续写，不然不会产生样式效果。\n\n\n\n#### 2、字体\n\n**加粗**：在字体两边分别加两个星号。\n\n*斜体*：在字体两边加一个星号。\n\n***粗体加斜体***：在字体两遍分别加三个星号。\n\n~~删除线~~：在字体两边分别加两个(～)波浪线。\n\n\n\n#### 3、引用\n\n在起始位置添加一个大于符号(>) + 空格，表示引用。\n\n> 一给我我里giaogiao！------giao哥\n\n\n\n#### 4、分割线\n\n可以用三个杠(_) + 空格\n\n___\n\n也可以用三个星号（*）+空格（这个分割线占全屏）\n\n***\n\n\n\n#### 5、图片\n\n样式（英文状态下的感叹号 加 中括号 加 小括号（ !+[ ]+()），中括号里面放图片的名字，小括号放图片的地址（图片可以是本地的图片也可以是网上的图片））。\n\n![江疏影](https://raw.githubusercontent.com/sectoo1s/images/main/202209292108314.jpeg)\n\n\n\n#### 6、超链接\n\n样式：（英文状态下的中括号 + 小括号（[ ]+( )）,中括号放超链接的名字，小括号放超链接的地址）\n\n[百度一下测试](https://baidu.com)\n\n\n\n#### 7、列表\n\n有序列表：样式(1 + .号 + 空格)\n\n1. a\n2. b\n3. c\n\n无序列表：样式(- 号 + 空格)\n\n- a\n- b\n- c\n\n#### 8、表格\n\nMac下快捷键插入：option + command + t\n\n\n\n#### 9、代码\n\n打开Typora后在编辑区输入三个点号，该键位在esc按键下方数字1的前面。然后输入html，注意要挨着三个点号不要加空格。回车后代码块出现，可在代码块中输入javascript代码，代码块右下角有指示当前语言为javascript。\n\n```javascript\nconsole.log('hello, typora!');\n```\n\n","tags":["typora"]},{"title":"NodeJS调用数据库查询手机号","url":"/2022/09/29/NodeJS调用数据库查询手机号/","content":"\n​\t最近一直在研究这个手机号，所以就搞了一个前三后四的补全方法。\n\n第一次写感觉还有很大的优化空间，不过目前可以使用就先将就一下。\n\n```javascript\n//引入程序所需要的包\nconst mysql = require(\"mysql\");\nconst readline = require(\"readline\");\n\n//创建一个数据库连接，并进行基础配置\nlet connection = mysql.createConnection({\n    host     : 'localhost',\n    user     : 'root',\n    password : 'root',\n    database : 'Database'\n  });\n\n//创建一个readline实例\nconst ql = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n})\n\n//读取用户输入的信息作为变量\nql.question(\"请输入手机号前三位数:\", (answer) => {\n    let pref = answer\n    ql.question(\"请输入手机号后四位数:\", (answer) =>{\n        let suffix = answer\n        ql.question(\"请输入手机号的省份:\", (answer) =>{\n            let province = answer\n            ql.question(\"请输入手机号的城市:\",(answer) =>{\n                let city = answer\n                console.log(pref, province, city);\n                //连接数据库并且创建查询语句，将用户输入的信息传入数据库进行匹配\n                connection.connect()\n                let phone = `SELECT phone FROM phone WHERE pref=${pref} and province='${province}' and city='${city}'`;\n                connection.query(phone, (err, result) =>{\n                    if(err){\n                        console.log('[SELECT ERROR] - ',err.message);\n                        return;\n                    }\n                    console.log('--------------------------SELECT----------------------------');\n                    //通过字符串转换将数据库中的杂乱数据进行格式化，只保留需要的手机信息\n                    let data = JSON.parse(JSON.stringify(result)) \n                    for(let i = 0; i < data.length; i++){\n                        console.log(data[i]['phone'] + `${suffix}`);\n                        // console.log(typeof(data))\n                    }\n                    console.log(`总共查询到${result.length}个手机号码`);\n                    console.log('------------------------------------------------------------\\n\\n'); \n                    connection.end()\n                    ql.close() \n                    })\n            })\n        })\n    })\n})\n```\n\n写着写着有点回调地狱的感觉了，看来后面还是需要修改的。\n\nhttps://qa.1r1g.com/sf/ask/2557869751/\n\n这文章好像可以解决，不过先不看了。\n","tags":["nodejs"]},{"title":"使用Typora-Hexo-Github创建个人博客","url":"/2022/09/18/使用Typora-Hexo-Github创建个人博客/","content":"\n费劲了千辛万苦，我终于把自己的博客网站搭建起来了。\n\n中间踩了很多很多坑，准备写一篇博客记录一下。\n\n需要准备这些东西：\n\n- github账户\n- typora软件\n- Picgo软件\n\n### Github设置\n\n####  \t\t1、创建存储库\n\n首先就是要新建一个github仓库，因为我们要将代码存放在其中。\n\n来到github个人界面的存储库位置，点击新建。\n\n![image-20220918131107828](https://raw.githubusercontent.com/sectoo1s/images/main/202209181747215.png)\n\n\n\n这里创建的存储库名字，按照用户名.github.io来填写。\n\n一定要跟自己的名字保持一致，就像我这样。\n\n因为我已经创建过了，所以提示不可用。\n\n![image-20220918131301325](https://raw.githubusercontent.com/sectoo1s/images/main/202209181747079.png)\n\n​\t\n\n如果你的名字不一致就会出现这种状况。\n\n它不能够直接访问，而是跟你的用户名叠加在一起，非常的不美观。\n\n![image-20220918131642135](https://raw.githubusercontent.com/sectoo1s/images/main/202209181747918.png)\n\n\n\n​\t一致的话则可以通过 `用户名.github.io` 直接访问，就像这样高端大气上档次。\n\n![image-20220918131945517](https://raw.githubusercontent.com/sectoo1s/images/main/202209181747594.png)\n\n\n\n#### \t2、绑定github仓库\n\n将本地信息跟github存储库关联起来，这个在创建仓库的时候会给一个提示。\n\n不会的可以去跟着学一下，操作比较简单。\t\n\n配置好之后可以在本地的命令行进行操作。\n\n​\t\n\n### hexo安装\n\n​\t安装之前要确保自己的电脑上有nodejs，不然没办法进行后续的操作。\n\n先在电脑上创建一个myBlog文件夹，然后执行以下命令来安装hexo框架。\n\n```nodejs\nsudo npm install -g hexo-cli\n```\n\n![image-20220918142304810](https://raw.githubusercontent.com/sectoo1s/images/main/202209181747328.png)\n\n安装完成后\n\n初始化博客：**`hexo init`**\n\n静态部署：\t**`hexo g`**\n\n![](https://raw.githubusercontent.com/sectoo1s/images/main/202209181747480.png)\n\n本地查看网页：**`hexo s`**\n\n![image-20220918142651777](https://raw.githubusercontent.com/sectoo1s/images/main/202209181747399.png)\n\n浏览器访问 [http://localhost:4000](https://link.zhihu.com/?target=http%3A//baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%9C%80%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%95%88%E6%9E%9C%E4%BA%86) 打开新部署的网页：\n\n![image-20220918142637383](https://raw.githubusercontent.com/sectoo1s/images/main/202209181747922.png)\n\n看到这个页面就说明安装成功。\n\n\n\n#### 更换主题\n\n但是我不想使用这个主题，感觉不太好看，所以我又重新找了一款。\n\n直接找到github然后clone下来，然后复制粘贴到`myBlog`的`themes`文件夹。跟着教程进行相关配置，最后是这样的。\n\n![](https://raw.githubusercontent.com/sectoo1s/images/main/202209181826469.png)\n\n#### 同步到github\n\n使用命令安装部署插件\n\n```\nnpm install hexo-deployer-git --save\n```\n\n然后执行**`hexo d`**将本地的博客部署到github\n\n![image-20220918182928609](https://raw.githubusercontent.com/sectoo1s/images/main/202209181829671.png)\n\n如果你是第一次上传则需要输入用户名和密码。\n\n**注意这里的密码是token而不是登录密码,需要去github生成。**\n\n\n\n### 使用PicGo上传图片\n\n#### 1、解析问题\n\n如果按照上述操作弄完之后，你应该会遇到一个问题。\n\n那就是在本地MarkDown插入的图片，到网页中没有办法解析。\n\n他会呈现一种破碎图片的状态，我在这里卡了很久。\n\n看了很多转换插件，但是都不太好用。\n\n**最后选择了使用picgo,体验还不错。**\n\n![image-20220918183641728](https://raw.githubusercontent.com/sectoo1s/images/main/202209181836778.png)\n\n\n\n#### 2、picgo配置操作\n\n打开typora的**`偏好设置`**,选中其中的**`图像`**，如下配置。\n\n![image-20220918184013527](https://raw.githubusercontent.com/sectoo1s/images/main/202209181840608.png)\n\n最主要的是这个picgo.app,点击下载进行安装，将你的存储库信息填写进去。\n\n![image-20220918184101280](https://raw.githubusercontent.com/sectoo1s/images/main/202209181841337.png)\n\n**这个配置中一定要创建一个新的存储库，我这里叫做images。**\n\n**不要在博客存储库下面创建文件夹，因为那样不起作用！**\n\n创建好之后点击验证，如果能够成功返回url则说明能够解析。\n\n![image-20220918184342486](https://raw.githubusercontent.com/sectoo1s/images/main/202209181843548.png)\n\n","tags":["hexo"]}]